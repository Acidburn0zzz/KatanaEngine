#if 0	// This is now handled through our new rendering pipeline ~hogsy
	int i;

	if (r_showtris.value < 1 || r_showtris.value > 2 || cl.maxclients > 1)
		return;

	if(r_showtris.value == 1)
		glDisable(GL_DEPTH_TEST);

	glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);

	GL_PolygonOffset(OFFSET_SHOWTRIS);

	Video_DisableCapabilities(VIDEO_TEXTURE_2D);

	glColor3f(1.0f,1.0f,1.0f);

	if(r_drawworld.value)
		R_DrawTextureChains_ShowTris();

	if (r_drawentities.value)
	{
		for (i=0 ; i<cl_numvisedicts ; i++)
		{
			currententity = cl_visedicts[i];

			if (currententity == &cl_entities[cl.viewentity]) // chasecam
				currententity->angles[0] *= 0.3f;

			switch (currententity->model->mType)
			{
			case MODEL_BRUSH:
				R_DrawBrushModel_ShowTris (currententity);
				break;
			case MODEL_TYPE_MD2:
				R_DrawAliasModel_ShowTris (currententity);
				break;
			case MODEL_SPRITE:
			default:
				break;
			}
		}

		// viewmodel
		currententity = &cl.viewent;
		if (r_drawviewmodel.value
			&& !chase_active.value
			&& !bEnvironmentMap
			&& cl.stats[STAT_HEALTH] > 0
			&& !(cl.items & IT_INVISIBILITY)
			&& currententity->model
			&& currententity->model->mType == MODEL_TYPE_MD2)
		{
			glDepthRange(0,0.3);
			R_DrawAliasModel_ShowTris(currententity);
			glDepthRange(0,1);
		}
	}

	glColor3f (1,1,1);
	glEnable (GL_TEXTURE_2D);
	glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
	GL_PolygonOffset (OFFSET_NONE);

	if (r_showtris.value == 1)
		glEnable (GL_DEPTH_TEST);
#endif

#else
	glpoly_t	*p;
	texture_t	*t;
	float		*v;
	float		entalpha;
	int			i;

	t = R_TextureAnimation (s->texinfo->texture, currententity->frame);
	entalpha = ENTALPHA_DECODE(currententity->alpha);

// drawflat
	if (r_drawflat_cheatsafe)
	{
		if ((s->flags & SURF_DRAWTURB) && r_oldwater.value)
		{
			for (p = s->polys->next; p; p = p->next)
			{
				srand((unsigned int) p);
				glColor3f (rand()%256/255.0, rand()%256/255.0, rand()%256/255.0);
				DrawGLPoly (p);
				rs_brushpasses++;
			}
			return;
		}

		srand((unsigned int) s->polys);
		glColor3f (rand()%256/255.0, rand()%256/255.0, rand()%256/255.0);
		DrawGLPoly (s->polys);
		rs_brushpasses++;
		return;
	}

// fullbright
	if((r_fullbright_cheatsafe) && !(s->flags & SURF_DRAWTILED))
	{
		if(entalpha < 1.0f)
		{
			Video_EnableCapabilities(VIDEO_BLEND);
			Video_SetBlend(VIDEO_BLEND_IGNORE,VIDEO_DEPTH_FALSE);

			glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
			glColor4f(1.0f,1.0f,1.0f,entalpha);
		}

		Video_SetTexture(t->gltexture);
		DrawGLPoly (s->polys);
		rs_brushpasses++;

		if(entalpha < 1.0f)
		{
			Video_DisableCapabilities(VIDEO_BLEND);
			Video_SetBlend(VIDEO_BLEND_IGNORE,VIDEO_DEPTH_TRUE);

			glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);
			glColor3f(1.0f,1.0f,1.0f);
		}

		goto fullbrights;
	}

// r_lightmap
	if (r_lightmap_cheatsafe)
	{
		if (s->flags & SURF_DRAWTILED)
		{
			Video_DisableCapabilities(VIDEO_TEXTURE_2D);

			DrawGLPoly (s->polys);

			Video_EnableCapabilities(VIDEO_TEXTURE_2D);

			rs_brushpasses++;
			return;
		}

		R_RenderDynamicLightmaps(s);

		Video_SetTexture(lightmap_textures[s->lightmaptexturenum]);

		R_UploadLightmap(s->lightmaptexturenum);

		if (!gl_overbright.value)
		{
			glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
			glColor3f(0.5f,0.5f,0.5f);
		}

		glBegin(GL_TRIANGLE_FAN);

		v = s->polys->verts[0];
		for (i=0 ; i<s->polys->numverts ; i++, v+= VERTEXSIZE)
		{
			glTexCoord2f (v[5], v[6]);
			glVertex3fv (v);
		}

		glEnd();

		if(!gl_overbright.value)
		{
			glColor3f(1.0f,1.0f,1.0f);
			glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);
		}

		rs_brushpasses++;

		return;
	}

// missing texture


// lightmapped poly
	if(entalpha < 1.0f)
	{
		glDepthMask(false);
		glEnable(GL_BLEND);
		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
		glColor4f(1.0f,1.0f,1.0f,entalpha);
	}
	else
		glColor3f(5.0f,1.0f,1.0f);

	if(gl_overbright.value)
	{
		else if (entalpha < 1.0f) //case 2: can't do multipass if entity has alpha, so just draw the texture
		{
			Video_SetTexture(t->gltexture);
			DrawGLPoly (s->polys);
			rs_brushpasses++;
		}
		else //case 3: texture in one pass, lightmap in second pass using 2x modulation blend func, fog in third pass
		{
			//first pass -- texture with no fog
			Fog_DisableGFog ();
			Video_SetTexture(t->gltexture);
			DrawGLPoly (s->polys);

			Fog_EnableGFog ();

			rs_brushpasses++;

			//second pass -- lightmap with black fog, modulate blended
			R_RenderDynamicLightmaps (s);

			Video_SetTexture(lightmap_textures[s->lightmaptexturenum]);

			R_UploadLightmap(s->lightmaptexturenum);

			glDepthMask(false);
			glEnable(GL_BLEND);
			glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR); //2x modulate

			Fog_StartAdditive ();

			glBegin(GL_POLYGON);

			v = s->polys->verts[0];
			for (i=0 ; i<s->polys->numverts ; i++, v+= VERTEXSIZE)
			{
				glTexCoord2f (v[5], v[6]);
				glVertex3fv (v);
			}

			glEnd ();

			Fog_StopAdditive ();

			rs_brushpasses++;

			//third pass -- black geo with normal fog, additive blended
			if (Fog_GetDensity() > 0)
			{
				glBlendFunc(GL_ONE, GL_ONE); //add
				glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
				glColor3f(0,0,0);
				DrawGLPoly (s->polys);
				glColor3f(1,1,1);
				glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
				rs_brushpasses++;
			}

			glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			glDisable (GL_BLEND);
			glDepthMask (GL_TRUE);
		}
	}
	else
	{
		if(Video.bMultitexture) //case 4: texture and lightmap in one pass, regular modulation
		{
			Video_DisableMultitexture(); // selects TEXTURE0
			Video_SetTexture(t->gltexture);

			glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

			Video_EnableMultitexture(); // selects TEXTURE1
			Video_SetTexture(lightmap_textures[s->lightmaptexturenum]);

			R_RenderDynamicLightmaps (s);
			R_UploadLightmap(s->lightmaptexturenum);

			glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
			glBegin(GL_POLYGON);

			v = s->polys->verts[0];
			for (i=0 ; i<s->polys->numverts ; i++, v+= VERTEXSIZE)
			{
				glMultiTexCoord2fARB(VIDEO_TEXTURE0,v[3],v[4]);
				glMultiTexCoord2fARB(VIDEO_TEXTURE1,v[5],v[6]);
				glVertex3fv (v);
			}
			glEnd ();

			Video_DisableMultitexture();

			rs_brushpasses++;
		}
		else if (entalpha < 1) //case 5: can't do multipass if entity has alpha, so just draw the texture
		{
			Video_SetTexture(t->gltexture);
			DrawGLPoly (s->polys);
			rs_brushpasses++;
		}
		else //case 6: texture in one pass, lightmap in a second pass, fog in third pass
		{
			//first pass -- texture with no fog
			Fog_DisableGFog ();
			Video_SetTexture(t->gltexture);
			DrawGLPoly (s->polys);
			Fog_EnableGFog ();
			rs_brushpasses++;

			//second pass -- lightmap with black fog, modulate blended
			R_RenderDynamicLightmaps(s);
			Video_SetTexture(lightmap_textures[s->lightmaptexturenum]);
			R_UploadLightmap(s->lightmaptexturenum);

			glDepthMask (GL_FALSE);
			glEnable (GL_BLEND);
			glBlendFunc (GL_ZERO, GL_SRC_COLOR); //modulate
			Fog_StartAdditive ();

			glBegin(GL_POLYGON);
			v = s->polys->verts[0];
			for (i=0 ; i<s->polys->numverts ; i++, v+= VERTEXSIZE)
			{
				glTexCoord2f (v[5], v[6]);
				glVertex3fv (v);
			}
			glEnd();

			Fog_StopAdditive ();
			rs_brushpasses++;

			//third pass -- black geo with normal fog, additive blended
			if (Fog_GetDensity() > 0)
			{
				glBlendFunc(GL_ONE, GL_ONE); //add
				glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
				glColor3f(0,0,0);
				DrawGLPoly (s->polys);
				glColor3f(1,1,1);
				glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
				rs_brushpasses++;
			}

            Video_DisableCapabilities(VIDEO_BLEND);
            Video_SetBlend(VIDEO_BLEND_TWO,VIDEO_DEPTH_TRUE);
		}
	}

	if(entalpha < 1.0f)
	{
        Video_SetBlend(VIDEO_BLEND_IGNORE,VIDEO_DEPTH_TRUE);
        Video_DisableCapabilities(VIDEO_BLEND);

		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		glColor3f(1.0f,1.0f,1.0f);
	}

fullbrights:
	if (gl_fullbrights.value && t->fullbright)
	{
		Video_SetBlend(VIDEO_BLEND_ONE,VIDEO_DEPTH_FALSE);
		Video_EnableCapabilities(VIDEO_BLEND);

		glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
		glColor3f(entalpha,entalpha,entalpha);

		Video_SetTexture(t->fullbright);

		Fog_StartAdditive ();
		DrawGLPoly (s->polys);
		Fog_StopAdditive ();

		glColor3f(1.0f,1.0f,1.0f);
		glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_REPLACE);

        Video_DisableCapabilities(VIDEO_BLEND);
		Video_SetBlend(VIDEO_BLEND_TWO,VIDEO_DEPTH_TRUE);

		rs_brushpasses++;
	}
#endif

#if 0
void GL_DrawSpriteModel(entity_t *e)
{
	vec3_t			point, v_forward, v_right, v_up;
	msprite_t		*psprite;
	mspriteframe_t	*frame;
	float			*s_up, *s_right;
	float			angle, sr, cr;

	frame = R_GetSpriteFrame (e);
	psprite = currententity->model->cache.data;

	switch(psprite->type)
	{
	case SPR_VP_PARALLEL_UPRIGHT: //faces view plane, up is towards the heavens
		v_up[0] = 0;
		v_up[1] = 0;
		v_up[2] = 1;
		s_up = v_up;
		s_right = vright;
		break;
	case SPR_FACING_UPRIGHT: //faces camera origin, up is towards the heavens
		Math_VectorSubtract(currententity->origin, r_origin, v_forward);
		v_forward[2] = 0;
		Math_VectorNormalizeFast(v_forward);
		v_right[0] = v_forward[1];
		v_right[1] = -v_forward[0];
		v_right[2] = 0;
		v_up[0] = 0;
		v_up[1] = 0;
		v_up[2] = 1;
		s_up = v_up;
		s_right = v_right;
		break;
	case SPR_VP_PARALLEL: //faces view plane, up is towards the top of the screen
		s_up = vup;
		s_right = vright;
		break;
	case SPR_ORIENTED: //pitch yaw roll are independent of camera
		Math_AngleVectors(currententity->angles, v_forward, v_right, v_up);
		s_up = v_up;
		s_right = v_right;
		GL_PolygonOffset(OFFSET_DECAL);
		break;
	case SPR_VP_PARALLEL_ORIENTED: //faces view plane, but obeys roll value
		angle = currententity->angles[ROLL] * M_PI_DIV_180;
		sr = sin(angle);
		cr = cos(angle);
		v_right[0] = vright[0] * cr + vup[0] * sr;
		v_right[1] = vright[1] * cr + vup[1] * sr;
		v_right[2] = vright[2] * cr + vup[2] * sr;
		v_up[0] = vright[0] * -sr + vup[0] * cr;
		v_up[1] = vright[1] * -sr + vup[1] * cr;
		v_up[2] = vright[2] * -sr + vup[2] * cr;
		s_up = v_up;
		s_right = v_right;
		break;
	default:
		return;
	}

	glColor3f (1,1,1);

	Video_DisableMultitexture();
	Video_SetTexture(frame->gltexture);

	glEnable (GL_ALPHA_TEST);
	glBegin (GL_TRIANGLE_FAN); //was GL_QUADS, but changed to support r_showtris

	glTexCoord2f (0, frame->tmax);
	Math_VectorMA(e->origin, frame->down, s_up, point);
	Math_VectorMA (point, frame->left, s_right, point);
	glVertex3fv (point);

	glTexCoord2f (0, 0);
	Math_VectorMA (e->origin, frame->up, s_up, point);
	Math_VectorMA (point, frame->left, s_right, point);
	glVertex3fv (point);

	glTexCoord2f (frame->smax, 0);
	Math_VectorMA (e->origin, frame->up, s_up, point);
	Math_VectorMA (point, frame->right, s_right, point);
	glVertex3fv (point);

	glTexCoord2f (frame->smax, frame->tmax);
	Math_VectorMA (e->origin, frame->down, s_up, point);
	Math_VectorMA (point, frame->right, s_right, point);
	glVertex3fv (point);

	glEnd ();
	glDisable (GL_ALPHA_TEST);

	//johnfitz: offset decals
	if (psprite->type == SPR_ORIENTED)
		GL_PolygonOffset (OFFSET_NONE);
}
#endif

